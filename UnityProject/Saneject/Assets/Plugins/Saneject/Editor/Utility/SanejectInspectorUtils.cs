using System;
using System.Collections.Generic;
using System.Reflection;
using Plugins.Saneject.Runtime.Attributes;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Plugins.Saneject.Editor.Utility
{
    /// <summary>
    /// Utility methods for custom inspectors to render <see cref="MonoBehaviour" /> fields and interface fields
    /// in the correct order, ensuring backing fields generated by Roslyn for <see cref="SerializeInterfaceAttribute" />
    /// appear alongside their declared interface fields.
    /// </summary>
    public static class SanejectInspectorUtils
    {
        /// <summary>
        /// Draws the "Script" field at the top of the inspector, matching the default Unity inspector.
        /// </summary>
        /// <param name="targets">All selected objects (multi-editing support).</param>
        /// <param name="target">The target object being drawn.</param>
        public static void DrawScriptField(
            Object[] targets,
            Object target)
        {
            if (targets.Length == 1 && target is MonoBehaviour mono)
            {
                EditorGUI.BeginDisabledGroup(true);
                EditorGUILayout.ObjectField("Script", MonoScript.FromMonoBehaviour(mono), typeof(MonoScript), false);
                EditorGUI.EndDisabledGroup();
            }
        }

        /// <summary>
        /// Draws all serialized fields for a <see cref="MonoBehaviour" />, ensuring interface backing fields generated
        /// in partial classes are displayed immediately after their associated interface field, not at the end of the inspector.
        /// Due to limitations in Unity's PropertyDrawer system, <c>[Inject]</c> and <c>[ReadOnly]</c> collections (lists/arrays)
        /// are also drawn here instead of via PropertyDrawers.
        /// </summary>
        /// <param name="serializedObject">The serialized object to draw fields from.</param>
        /// <param name="target">The target object being drawn.</param>
        public static void DrawAllSerializedFields(
            SerializedObject serializedObject,
            Object target)
        {
            HashSet<string> drawn = new();

            foreach (FieldInfo field in GetOrderedFields(target.GetType()))
            {
                if (!ShouldDrawField(field))
                    continue;

                if (field.Name == "m_Script")
                    continue;

                if (IsSerializeInterfaceField(field))
                {
                    string backingName = "__" + field.Name;
                    SerializedProperty property = serializedObject.FindProperty(backingName);

                    if (property != null && drawn.Add(property.propertyPath))
                        EditorGUILayout.PropertyField(
                            property,
                            new GUIContent(ObjectNames.NicifyVariableName(field.Name)),
                            true
                        );
                }
                else
                {
                    SerializedProperty prop = serializedObject.FindProperty(field.Name);

                    if (prop != null && drawn.Add(prop.propertyPath))
                    {
                        if (ShouldDrawAsReadOnlyCollection(field, prop))
                            DrawReadOnlyCollection(prop);
                        else
                            EditorGUILayout.PropertyField(prop, true);
                    }
                }
            }
        }

        /// <summary>
        /// Determines whether a collection field should be drawn as a non-editable list,
        /// based on the presence of <c>[Inject]</c> or <c>[ReadOnly]</c> attributes.
        /// </summary>
        public static bool ShouldDrawAsReadOnlyCollection(
            FieldInfo field,
            SerializedProperty prop)
        {
            return prop.isArray && prop.propertyType != SerializedPropertyType.String &&
                   (field.IsDefined(typeof(ReadOnlyAttribute), false) ||
                    field.IsDefined(typeof(InjectAttribute), false));
        }

        /// <summary>
        /// Renders a list or array property in a read-only format, mimicking Unity's native collection layout but with editing disabled.
        /// </summary>
        public static void DrawReadOnlyCollection(SerializedProperty prop)
        {
            Rect fullRect = GUILayoutUtility.GetRect(1f, EditorGUIUtility.singleLineHeight, GUILayout.ExpandWidth(true));

            // Background highlight excluding count
            Rect bgRect = new(fullRect.x, fullRect.y, fullRect.width - 48, fullRect.height);

            if (bgRect.Contains(Event.current.mousePosition))
                EditorGUI.DrawRect(bgRect, EditorGUIUtility.isProSkin
                    ? new Color(1f, 1f, 1f, 0.05f)
                    : new Color(0f, 0f, 0f, 0.1f));

            // Foldout toggle
            Rect foldoutRect = new(fullRect.x, fullRect.y, fullRect.width - 48, fullRect.height);
            prop.isExpanded = EditorGUI.Foldout(foldoutRect, prop.isExpanded, GUIContent.none, true);

            // Label without indent (manually positioned)
            Rect labelRect = new(foldoutRect.x + 1, foldoutRect.y, foldoutRect.width - 1, foldoutRect.height);
            EditorGUI.LabelField(labelRect, ObjectNames.NicifyVariableName(prop.name), EditorStyles.boldLabel);

            // Right-aligned item count
            Rect countRect = new(fullRect.xMax - 48, fullRect.y, 48, fullRect.height);
            EditorGUI.BeginDisabledGroup(true);
            EditorGUI.IntField(countRect, GUIContent.none, prop.arraySize);
            EditorGUI.EndDisabledGroup();

            if (!prop.isExpanded)
                return;

            EditorGUI.BeginDisabledGroup(true);

            for (int i = 0; i < prop.arraySize; i++)
            {
                SerializedProperty element = prop.GetArrayElementAtIndex(i);
                string label = $"Element {i}";

                switch (element.propertyType)
                {
                    case SerializedPropertyType.ObjectReference:
                        EditorGUILayout.ObjectField(label, element.objectReferenceValue, typeof(Object), false);
                        break;
                    case SerializedPropertyType.String:
                        EditorGUILayout.TextField(label, element.stringValue);
                        break;
                    case SerializedPropertyType.Integer:
                        EditorGUILayout.IntField(label, element.intValue);
                        break;
                    case SerializedPropertyType.Float:
                        EditorGUILayout.FloatField(label, element.floatValue);
                        break;
                    default:
                        EditorGUILayout.PropertyField(element, new GUIContent(label), true);
                        break;
                }
            }

            EditorGUI.EndDisabledGroup();
        }

        /// <summary>
        /// Returns all instance fields from a type and its base types (excluding <see cref="MonoBehaviour" />), in declaration order.
        /// </summary>
        public static FieldInfo[] GetOrderedFields(Type type)
        {
            List<FieldInfo> fields = new();

            while (type != typeof(MonoBehaviour) && type != typeof(object) && type != null)
            {
                fields.InsertRange(0, type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly));
                type = type.BaseType;
            }

            return fields.ToArray();
        }

        /// <summary>
        /// Determines whether a field should be displayed in the inspector, based on serialization and visibility attributes.
        /// </summary>
        public static bool ShouldDrawField(FieldInfo fieldInfo)
        {
            if (fieldInfo.IsDefined(typeof(NonSerializedAttribute), false))
                return false;

            if (fieldInfo.IsDefined(typeof(HideInInspector), false))
                return false;

            if (fieldInfo.Name.StartsWith("<"))
                return false;

            return fieldInfo.IsPublic || fieldInfo.IsDefined(typeof(SerializeField), false) || fieldInfo.IsDefined(typeof(SerializeInterfaceAttribute), false);
        }

        /// <summary>
        /// Returns true if the field is decorated with <c>[SerializeInterface]</c>, indicating a special backing field should be used.
        /// </summary>
        public static bool IsSerializeInterfaceField(FieldInfo fieldInfo)
        {
            return fieldInfo.IsDefined(typeof(SerializeInterfaceAttribute), false);
        }
    }
}