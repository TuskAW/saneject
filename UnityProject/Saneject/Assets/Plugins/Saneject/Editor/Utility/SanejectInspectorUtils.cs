using System;
using System.Collections.Generic;
using System.Reflection;
using Plugins.Saneject.Runtime.Attributes;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Plugins.Saneject.Editor.Utility
{
    /// <summary>
    /// Utility methods for custom inspectors to render <see cref="MonoBehaviour" /> fields and interface fields
    /// in the correct order, ensuring backing fields generated by Roslyn for <see cref="SerializeInterfaceAttribute" />
    /// appear alongside their declared interface fields.
    /// </summary>
    public static class SanejectInspectorUtils
    {
        /// <summary>
        /// Draws the "Script" field at the top of the inspector, matching the default Unity inspector.
        /// </summary>
        /// <param name="targets">All selected objects (multi-editing support).</param>
        /// <param name="target">The target object being drawn.</param>
        public static void DrawScriptField(
            Object[] targets,
            Object target)
        {
            if (targets.Length == 1 && target is MonoBehaviour mono)
            {
                EditorGUI.BeginDisabledGroup(true);
                EditorGUILayout.ObjectField("Script", MonoScript.FromMonoBehaviour(mono), typeof(MonoScript), false);
                EditorGUI.EndDisabledGroup();
            }
        }

        /// <summary>
        /// Draws all serialized fields for a <see cref="MonoBehaviour" />, ensuring interface backing fields generated
        /// in partial classes are displayed immediately after their associated interface field, not at the end of the inspector.
        /// </summary>
        /// <param name="serializedObject">The serialized object to draw fields from.</param>
        /// <param name="target">The target object being drawn.</param>
        public static void DrawAllSerializedFieldsWithCorrectInterfaceOrder(
            SerializedObject serializedObject,
            Object target)
        {
            HashSet<string> drawn = new();

            foreach (FieldInfo field in GetOrderedFields(target.GetType()))
            {
                if (!ShouldDrawField(field))
                    continue;

                if (field.Name == "m_Script")
                    continue;

                if (IsSerializeInterfaceField(field))
                {
                    string backingName = "__" + field.Name;
                    SerializedProperty property = serializedObject.FindProperty(backingName);

                    if (property != null && drawn.Add(property.propertyPath))
                        EditorGUILayout.PropertyField(
                            property,
                            new GUIContent(ObjectNames.NicifyVariableName(field.Name)),
                            true
                        );
                }
                else
                {
                    SerializedProperty prop = serializedObject.FindProperty(field.Name);

                    if (prop != null && drawn.Add(prop.propertyPath))
                        EditorGUILayout.PropertyField(prop, true);
                }
            }
        }

        /// <summary>
        /// Gets all instance fields for the type, base classes first, in normal declaration order.
        /// </summary>
        private static FieldInfo[] GetOrderedFields(Type type)
        {
            List<FieldInfo> fields = new();

            while (type != typeof(MonoBehaviour) && type != typeof(object) && type != null)
            {
                fields.InsertRange(0, type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly));
                type = type.BaseType;
            }

            return fields.ToArray();
        }

        /// <summary>
        /// Returns true if this field should be shown in the inspector.
        /// </summary>
        private static bool ShouldDrawField(FieldInfo fieldInfo)
        {
            if (fieldInfo.IsDefined(typeof(NonSerializedAttribute), false))
                return false;

            if (fieldInfo.IsDefined(typeof(HideInInspector), false))
                return false;

            if (fieldInfo.Name.StartsWith("<"))
                return false;

            return fieldInfo.IsPublic || fieldInfo.IsDefined(typeof(SerializeField), false) || fieldInfo.IsDefined(typeof(SerializeInterfaceAttribute), false);
        }

        /// <summary>
        /// True if field has <c>[SerializeInterface]</c>.
        /// </summary>
        private static bool IsSerializeInterfaceField(FieldInfo fieldInfo)
        {
            return fieldInfo.IsDefined(typeof(SerializeInterfaceAttribute), false);
        }
    }
}